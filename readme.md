# Общая концепция

1) Допускается только "CleanArchitecture", то есть жесткие ограничения на зависимости сущностей.

   Схема зависимостей:

    ```mermaid
    stateDiagram-v2
    
        state "Controllers (Wrappers for hardware, signaling, webrtc, ...)" as Controllers
        state "Gateways (REST, Sockets, ...)" as Gateways
        state "UseCases / Interactors - Business Logic" as UseCases
        state "Repositories (DB, Preferences, ...)" as Repo
        state "SDK (Public Interface)" as SDK
        
        UI --> UI_logic
        UI_logic --> UseCases
        Controllers --> UseCases
        Gateways --> UseCases
        Repo --> UseCases
        SDK --> UseCases
    ```

   Здесь:

   - **UI** - это композиция отображения - Compose-function, или Fragment + xml или Activity + xml. Но
     лучше первое, потому что декларативный подход легче понимать, легче поддерживать.
   - **UI-logic** - это ViewModel
   - **Controllers** - классы взаимодействия с платформой или железом. Это могут быть большие пакеты со
     множеством классов и сложной структурой. Сюда же можно отнести обвес WebRTC, управление камерой,
     аудио подсистему и пр.
   - **Gateways** - сетевой слой.
   - **Repositories** - репозитории для хранения данных
   - **SDK** - это интерфейс для сторонних клиентов в более широком смысле чем просто
     класс интерфейса. Все то, что нужно для общения в/из вне.
   - **UseCases** - вот это чистая абстракция всех процессов внутри приложения, то есть "Бизнес-логика".
     В основном - это Iteractor'ы или аналогичные классы. Они не зависят ни от чего,
     кроме классов этого же уровня и доменных моделей. Логика должна работать также, если ее перенести
     на другую платформу. Если это не так, значит архитектура нарушена.
     Классы этого "доменного" слоя должны отвечать на вопрос "Что происходит?", но категорически не
     должны содержать "Как это происходит", за это отвечают компоненты, **зависящие** от доменного слоя.

2) Бизнес логика манипулирует абстракциями. Ее задача облегчение понимания кейсов без конкретики.
   Модели, которыми оперирует бизнес-логика, не должны учитывать технические особенности платформы
   или конкретного устройства. Если такие зависимости есть (например, isVisor), то модели с такими
   свойствами должны быть абстрактными.

3) Презентационный слой наоборот знает как должно все выглядеть, но не "заморачивается" на бизнес
   кейсах. Он с одной стороны подписывается на события бизнес-логики ("слушает изменения") и на
   основе изменений строит интерфейс. С другой стороны презентационный слой "слушает" действия
   пользователя и передает их в слой бинес-логики, но уже в абстракциях, понятных ей.

4) Презентационный слой всех элементов любого размера всегда должен состоять из 2-х частей:
   отрисовки и абстрации презентационного слоя. Используем локальный MVI в составе: compose +
   ViewModel. Основной профит в таком разделении: легкость восприятия функционала и декларативный
   подход, обеспечивающий единство ответственности.

5) Каждый экран вызывается и взаимодействует только только со своим родителем.
   Если нужно его показать - это зона ответственности родителя. Родитель ничего не знает (и не
   должен!) о внутренностях своих детей. Однако если это диалог или другой интерактивный элемент,
   находящийся на экране временно и возвращающий некоторый результат, то родитель может получить
   его. Для этого можно использовать:

   - интерфейс, передаваемый "ребенку"
   - родительскую вью-модель (ее время жизни всегда больше любого ребенка), обеспечивая правильные
     ключи при создании через фабрику
   - общую бизнес-логику, если интерактор живет долго его могут слушать разные элементы интерфейса

6) Сдедующие понятия должны быть исключены, как противоречащие концепции.

   - Интерактор должен отобразить диалог.
   - Фича должна дернуть...
   - Фича должна показать...
   - Фича А вызывает фичу Б (или любые подобные комбинации)

7) Маршрутизация (или роутинг) - это переход по экранам с одновременным <u>требуемым</u> изменением
   бэкстека. Может применяться для отдельных "фичей", в которых действительно есть несколько
   полностью заменяющих друг друга экранов, например, "опросы" или "перенос касанием". Базовый
   функционал не требует никакой навигации из-за отсутствия необходимости переходов по окнам. Это
   лишь ненужное усложнение. Не надо путать маршрутизацию и вызов диалога из бизнес-логики.
   Последнее - это архитектурная ошибка, см. п.1.
   Маршрутизация должна выполнять только свою функцию - переход по экранам, то есть вызываться из UI
   слоя и его же представлять. Хотя внутри может использовать бизнес-логику по тем же принципам, что
   написаны выше.

# Состояния интерфейса базовой активити

```mermaid
stateDiagram-v2
    [*] --> SignIn
   SignIn --> Loader
   state variants <<fork>>
   Loader --> variants
   variants --> Conference
   variants --> Lobby
   variants --> Webinar
   Lobby --> Conference
   state join <<join>>
   Conference --> join
   Webinar --> join
   join --> Stars
   join --> TerminateError
   Loader --> TerminateError
   Stars --> [*]
   TerminateError --> SignIn
   Lobby --> [*]
   TerminateError --> [*]
```

Так выглядит система переходов основных экранов. Каждый экран имеет свое внутреннее наполнение и
может иметь сложную логику, но базовая активити не управляет этим, ее компетенция заключается только
в переключении этих основных экранов.

Это просто, понятно и легко поддерживается. Легко добавить еще элемент, если в какой-то момент от
бизнеса поступит требование добавить еще, например, "карточную игру" или "платежный сервис" как еще
один шаг, например, после шага авторизации (или вместо лоадера, или вебинара и т.п.).

Легко изменить логику переходов, потому что это всего лишь `state + when`.

# Конференция

Интерфейс конференции состоит из нескольких композиций (блоков), которые могут быть видны поочередно
или одновременно в зависимости от типа экрана устройства или расположения (вертикально или
горизонтально).

Основные блоки (композиции):

- Видео в полноэкранном режиме
- Плитки с видео участников
- Чат
- Список участников
- Основные контролы (кнопки: чат, микрофон, трубка, камера, "дополнительно", настройки)
- Дополнительные контролы
- Уведомления
- Название конференции, таймер

Каждый элемент организует собственную часть экрана независимо от других элементов. UI конференции
является лишь "компоновщиком". Таким образом "видео", чат, список сотрудников, контролы и пр.
элементы могут присутствовать на экране, а могут и не отображаться. Каждый элемент независим и имеет
свою вью модель. Если элемент не отображается, то и связанная с ним UI-логика не выполняется. Логика
отображения отдельного элемента становится легче, потому что она не перегружена ничем лишним. Все
визуальные элементы в итоге привязаны к слою бизнес логики, который является абстракцией
конференции.

С другой стороны абстракция конференции используется контроллерами, обслуживающими физический
уровень (состояние камер, аудио системы, каналы связи с сервером, webrtc и пр.). Необходимо
обязательно соблюдать условия зависимостей. Бизнес логика зависит от контроллеров, но не наоборот.
Если включилась видеокамера или микрофон, контроллер сообщает об этом бизнес-логике. Контроллер
камеры может проверять некоторые флаги бизнес-логики, для ограничения возможности включения и т.п.

# Структурная схема взаимодействия блоков приложения

```mermaid
flowchart
    sign-in["Экран присоединения"]:::ui
    lobby["Экран Лобби"]:::ui
    conference["Экран активной конференции"]:::ui
    webinar["Экран вебинара"]:::ui
    connect-logic["Интерактор логики присоединения"]:::logic
    conference-logic["Интерактор состояния конференции"]:::logic
    webinar-logic["Интерактор состояния вебинара"]:::logic
    networking["Сетевой слой"]:::platform
    signaling["Клиент сигнализации"]:::platform
    webrtc["Клиент WebRTC"]:::platform
    local-media["Контроллер локальных медиа-устройств"]:::platform
    sign-in <--> connect-logic
    connect-logic & signaling & webrtc <--> networking
    lobby <--> conference-logic
    webinar <--> webinar-logic
    conference <--> conference-logic
    conference-logic <--> signaling
    conference-logic <--> webrtc
    conference-logic <--> local-media
    webinar-logic <--> signaling
   classDef ui stroke: #00f, stroke-width: 4px
   classDef logic stroke: #f00, stroke-width: 4px
   classDef platform stroke: #0f0, stroke-width: 4px
```

# Функциональная диаграмма.

Как распределять код ко компонентам для любой функциональности (фичи).

```mermaid
sequenceDiagram
    participant main as MainComposable
    participant ui as Composables (UI)
    participant vm as ViewModels
    participant i as Interactors (UseCases)
    participant c as Controllers (Периферия, сигналинг, медиа-бридж, ...)
    participant d as Repositories
   main ->> ui: Запуск фичи, т.е. встраивание в интерфейс ее функционала
    activate ui
   vm ->> ui: UiState as StateFlow - Состояние интерфейса
    activate vm
   ui ->> vm: Нажатие "Закрыть диалог"
   vm ->> vm: Реакция на нажатие - изменение состояния интерфейса
   vm ->> ui: UiState as StateFlow - Состояние интерфейса
   ui ->> vm: Нажатие "Включить камеру"
   vm ->> i: Логическое "Включение камеры" для текущего состояния конференции
    activate i
    note over i: ConferenceInteractor
   i ->> c: Команда видеозахвата
    activate c
    note over c: LocalMediaController
   c ->> c: Физический запуск захвата изображения с камеры
   c ->> i: State as StateFlow - событие включения трека
    deactivate c
   i ->> vm: State as StateFlow - событие включения трека
    deactivate i
   vm ->> ui: UiState as StateFlow - Видим локальное видео
    deactivate vm
   main --> ui: Остановка функции
    deactivate ui
   main ->> ui: Запуск другой фичи, встраивание в интерфейс другого UI, например перенос касанием
    activate ui
   vm ->> ui: UiState as StateFlow - Состояние интерфейса
    activate vm
   ui ->> vm: Нажатие "Перенести"
   vm ->> i: Запускаем логику переноса
    activate i
    note over i: TransferInteractor
   i ->> i: Логика переноса
   i ->> c: Команда физического обмена с узлом в сети
    activate c
    note over c: SberCastController
   c ->> c: Взаимодействие на сетевом уровне
   c ->> i: Обратная связь
    deactivate c
   i ->> vm: State as StateFlow - событие результата переноса
    deactivate i
   vm ->> ui: UiState as StateFlow - Видим результат
    deactivate vm
   main --> ui: Остановка функции
    deactivate ui
```

# Что еще проработать...

- [+] Lobby
- [+] Webinar
- [+] Ошибка "перезайти во встречу"
- [+] Параллельный диплинк -> продолжить / новая конференция
- "Раскраска" - как внешнее приложение может обеспечить собственную темизацию.
- SDK/пример
- Как из терминального состояния перейти в экран внешнего "вызывающего" приложения
  > Предварительно - никак. Это не задача Jazz'а думать об окнах вызывающего приложения.
  Откуда вызвали туда и вернемся при выходе.

Набросок фабрики UI для возможности подмены.

```kotlin
interface Factory {
    val ui1: @Composable () -> Unit
    val ui2: @Composable () -> Unit
    val ui3: @Composable () -> Unit
    val chat: @Composable () -> Unit
    val users: @Composable () -> Unit
    // ...
}
```

# Соответствие официальным рекомендациям Goodle - Android App architecture

Ссылка на документацию https://developer.android.com/topic/architecture/intro

Состав рекомендаций:

| Рекомендация                                                                                                                | Текущий код | Новый код | Примечание                                                                                                                                                                                                                                                                                             |
|-----------------------------------------------------------------------------------------------------------------------------|:-----------:|:---------:|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Не храните данные(состояния) в компонентах приложения (Android)                                                             |      +      |     +     |                                                                                                                                                                                                                                                                                                        |
| Уменьшите зависимости от классов Android                                                                                    |      -      |     +     | В текущей архитектуре распространены взаимодействия с компонентами Android из бизнес-логики (вызов UI)                                                                                                                                                                                                 |
| Управление пользовательским интерфейсом на основе моделей данных                                                            |      -      |     +     | Концепция новой архитектуры подразумевает абстракцию UI во ViewModel's и абстракцию бизнес-логики в UseCase's                                                                                                                                                                                          |
| Единый источник истины                                                                                                      |     +/-     |     +     | В UI декларативный подход обеспечивает Compose, в бизнес логике новой архитектуры источником истины состояний выступают контроллеры, не храним состояние дополнительно (в отличии от текущей арх.). Однонаправленный поток данных обеспечивается использованием Flow                                   |
| Разбивка по слоям                                                                                                           |      -      |     +     | UI/Domain/Data, у нас так же есть Controllers Layer, который можно рассматривать как "машинный UI", то есть это такой же уровень, но управляемый(и наблюдаемый) железом или бэком                                                                                                                      | 
| Доменный слой не обязателен для простой логики                                                                              |      +      |     +     | Как показано на функциональной схеме некоторые простые действия могут обрабатываться внутри вьюмодели и для них необязательно нужен Interactor (исключение избыточности). [Как выбрать место где обрабатывать события](https://developer.android.com/topic/architecture/ui-layer/events#decision-tree) |
| Использование DI или сервис-локатора                                                                                        |      +      |     +     |                                                                                                                                                                                                                                                                                                        |
| Использование Hilt                                                                                                          |      -      |     ?     |                                                                                                                                                                                                                                                                                                        |
| Создайте чётко определённые границы ответственности между различными модулями вашего приложения                             |      -      |     +     |                                                                                                                                                                                                                                                                                                        |
| Как можно меньшая открытость каждого модуля                                                                                 |      +      |     +     |                                                                                                                                                                                                                                                                                                        |
| Как можно большая изолированность каждого модуля                                                                            |     +/-     |     +     |                                                                                                                                                                                                                                                                                                        |
| Классы сами отвечают за безопасный параллелизм                                                                              |      ?      |     ?     |                                                                                                                                                                                                                                                                                                        |
| Навигация                                                                                                                   |      -      |     +     | Концепция новой архитектуры точно соответствует [рекомендациям](https://developer.android.com/topic/architecture/ui-layer#navigation)                                                                                                                                                                  |
| Разделение логики на зависимую и не зависимую от ЖЦ                                                                         |      +      |     +     |                                                                                                                                                                                                                                                                                                        |
| ЖЦ доменного слоя                                                                                                           |      -      |     +     | В текущей архитектуре ЖЦ интеракторов не привязан к классам, которые их используют, что идет вразрез с [рекомендациями](https://developer.android.com/topic/architecture/domain-layer#lifecycle). Текущие интеракторы имеют собственный ЖЦ и состояния.                                                |
| Абстрагирование бизнес-логики                                                                                               |      ?      |     +     | Концепция новой архитектуры предполагает бизнес логику как сгруппированный набор "чистых" функций, которые оперируют только абстрактными моделями и не имеют собственных состояний.                                                                                                                    |
| **Настоятельно рекомендуется!** Используйте четко определенный уровень данных (серверная БЛ).                               |      -      |     +     | В текущей архитектуре нет четкого разделения по слоям.                                                                                                                                                                                                                                                 |
| **Настоятельно рекомендуется!** Используйте четко определенный уровень пользовательского интерфейса.                        |      -      |     +     |                                                                                                                                                                                                                                                                                                        |
| **Настоятельно рекомендуется!** Уровень данных (серверная БЛ) должен предоставлять данные приложения с помощью репозитория. |      -      |     ?     |                                                                                                                                                                                                                                                                                                        |
| **Настоятельно рекомендуется!** Используйте сопрограммы и потоки для взаимодействия между уровнями.                         |     +/-     |     ?     |                                                                                                                                                                                                                                                                                                        |
| Доменный слой для повторного использования бизнес-логики                                                                    |      +      |     +     |                                                                                                                                                                                                                                                                                                        |
| **Настоятельно рекомендуется!** В UI cледуйте однонаправленному потоку данных (UDF).                                        |     +/-     |     +     |                                                                                                                                                                                                                                                                                                        |
| **Настоятельно рекомендуется!** Используйте ViewModels, если их преимущества применимы к вашему приложению.                 |     +/-     |     +     |                                                                                                                                                                                                                                                                                                        |
| **Настоятельно рекомендуется!** Используйте коллекцию состояний пользовательского интерфейса с учетом жизненного цикла.     |     +/-     |     +     |                                                                                                                                                                                                                                                                                                        |
| **Настоятельно рекомендуется!** Не отправляйте события из ViewModel в пользовательский интерфейс.                           |      -      |     +     | Диалог - это состояние, а не событие!                                                                                                                                                                                                                                                                  |
| Single-activity                                                                                                             |     +/-     |     +     |                                                                                                                                                                                                                                                                                                        |
| Jetpack Compose                                                                                                             |      +      |     +     |                                                                                                                                                                                                                                                                                                        |
| **Настоятельно рекомендуется!** ViewModels не должны зависеть от жизненного цикла Android                                   |      +      |     +     |                                                                                                                                                                                                                                                                                                        |
| **Настоятельно рекомендуется!** Используйте сопрограммы и потоки.                                                           |      +      |     +     |                                                                                                                                                                                                                                                                                                        |
| **Настоятельно рекомендуется!** Не используйте ViewModels в повторно используемых частях пользовательского интерфейса       |      +      |     ?     |                                                                                                                                                                                                                                                                                                        |
| **Настоятельно рекомендуется!** Простые модели состояния UI в ViewModels                                                    |      +      |     +     |                                                                                                                                                                                                                                                                                                        |
| Не использовать AndroidViewModel                                                                                            |      +      |     +     |                                                                                                                                                                                                                                                                                                        |
| Используйте UI State                                                                                                        |     +/-     |     +     |                                                                                                                                                                                                                                                                                                        |
| **Настоятельно рекомендуется!** Не переопределяйте методы жизненного цикла в действиях или фрагментах.                      |      +      |     +     |                                                                                                                                                                                                                                                                                                        |
| **Настоятельно рекомендуется!** Используйте внедрение зависимостей.                                                         |      +      |     +     |                                                                                                                                                                                                                                                                                                        |
| **Настоятельно рекомендуется!** При необходимости перейдите к компоненту.                                                   |      -      |     ?     | В текущей архитектуре через DI создаются всё подряд, даже без особой необходимости                                                                                                                                                                                                                     |
| **Настоятельно рекомендуется!** Unit test ViewModels, including Flows.                                                      |      -      |     ?     |                                                                                                                                                                                                                                                                                                        |
| **Настоятельно рекомендуется!** Unit test data layer entities.                                                              |      -      |     ?     |                                                                                                                                                                                                                                                                                                        |
| **Настоятельно рекомендуется!** UI navigation tests that are useful as regression tests in CI                               |      -      |     ?     |                                                                                                                                                                                                                                                                                                        |
| **Настоятельно рекомендуется!** Моки для тестовых данных                                                                    |     +/-     |     ?     |                                                                                                                                                                                                                                                                                                        |
| **Настоятельно рекомендуется!** Test StateFlows                                                                             |      -      |     ?     |                                                                                                                                                                                                                                                                                                        |
| Создавайте модели для каждого слоя в сложных приложениях.                                                                   |      +      |     +     |                                                                                                                                                                                                                                                                                                        |

# Вопросы

- Какие преимущества дают отдельные Gradle-модули?
   * Не выяснено